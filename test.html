<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>FP‑317 Flip‑Dot Simulator</title>
	<style>
		:root {
			--scale: 8;           /* Size of each dot in CSS pixels */
			--cols: 84;           /* Panel width  */
			--rows: 28;           /* Panel height */
			--off: #1a1a1a;       /* Dot un‑flipped (dark)   */
			--on:  #ffffff;       /* Dot flipped   (yellow)  */
			--bg:  #000000;       /* Canvas background       */
		}
		body {
			margin: 0;
			padding: 1.5rem;
			background: #111;
			font-family: system-ui, sans-serif;
			color: #eee;
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 1rem;
		}
		#display {
			border: 4px solid #333;
			background: var(--bg);
			image-rendering: pixelated;
		}
		input[type="text"] {
			width: min(600px, 80%);
			padding: 0.5rem 0.75rem;
			font-size: 1.2rem;
			border-radius: 4px;
			border: none;
		}

		textarea#message {
			width: min(600px, 80%);
			padding: 0.5rem 0.75rem;
			font-size: 1.2rem;
			line-height: 1.4;
			resize: vertical;          /* let the user drag the corner */
			border-radius: 4px;
			border: none;
			font-family: inherit;
		}
	</style>
</head>
<body>
<h1>FP‑317 Flip‑Dot Simulator</h1>
<textarea id="message"
		  rows="4"
		  placeholder="Type or paste text – Enter starts a new line"
		  spellcheck="false"></textarea>
<canvas id="display"></canvas>
<script>
	/* ---------- Configuration ---------- */
	const SCALE = parseInt(
			getComputedStyle(document.documentElement).getPropertyValue("--scale")
	);
	const COLS = parseInt(
			getComputedStyle(document.documentElement).getPropertyValue("--cols")
	);
	const ROWS = parseInt(
			getComputedStyle(document.documentElement).getPropertyValue("--rows")
	);

	/* ---------- Canvas setup ---------- */
	const canvas = document.getElementById("display");
	canvas.width = COLS * SCALE;
	canvas.height = ROWS * SCALE;
	const ctx = canvas.getContext("2d");

	/* ---------- Color helpers ---------- */
	const COLOR_OFF = getComputedStyle(
			document.documentElement
	).getPropertyValue("--off").trim();
	const COLOR_ON = getComputedStyle(
			document.documentElement
	).getPropertyValue("--on").trim();

	const COLOR_BG = getComputedStyle(
			document.documentElement
	).getPropertyValue("--bg").trim();

	/* ---------- Font data ------------- */
	// Ferranti 7‑pixel font used by FP‑317 (converted from PROGMEM)
	const Ferranti7Bitmaps = new Uint8Array([
		0x00,0xfa,0x00,0xb4,0x57,0xd4,0xa5,0x7d,0x40,0x75,0x68,0xa2,0xd5,0xc0,
		0xce,0x84,0x44,0x2e,0x60,0xc0,0x00,0x6a,0xa4,0x00,0x95,0x58,0x00,0x25,
		0x5c,0xa8,0x80,0x00,0x01,0x09,0xf2,0x10,0x00,0xf7,0xe0,0xf0,0x01,0x22,
		0x44,0x80,0x69,0x99,0x99,0x60,0x59,0x24,0xb8,0x00,0x69,0x12,0x48,0xf0,
		0x69,0x16,0x19,0x60,0x26,0xaf,0x22,0x20,0xf8,0x8e,0x19,0x60,0x68,0x8e,
		0x99,0x60,0xf1,0x12,0x22,0x20,0x69,0x96,0x99,0x60,0x69,0x96,0x19,0x60,
		0x3c,0xf0,0x00,0xf3,0xdc,0x00,0x05,0x44,0x40,0x00,0x03,0x8e,0x00,0x00,
		0x11,0x15,0x00,0x00,0x69,0x12,0x40,0x40,0x74,0x6b,0x7b,0x41,0xe0,0x69,
		0x9f,0x99,0x90,0xe9,0x9e,0x99,0xe0,0x69,0x88,0x89,0x60,0xe9,0x99,0x99,
		0xe0,0xf8,0x8e,0x88,0xf0,0xf8,0x8e,0x88,0x80,0x69,0x8b,0x99,0x60,0x99,
		0x9f,0x99,0x90,0xe9,0x24,0xb8,0x00,0x11,0x11,0x19,0x60,0x9a,0xcc,0xa9,
		0x90,0x88,0x88,0x88,0xf0,0x8e,0xeb,0x18,0xc6,0x20,0x99,0xdb,0x99,0x90,
		0x69,0x99,0x99,0x60,0xe9,0x9e,0x88,0x80,0x69,0x99,0x9a,0x50,0xe9,0x9e,
		0x99,0x90,0x69,0x86,0x19,0x60,0xf9,0x08,0x42,0x10,0x80,0x99,0x99,0x99,
		0x60,0x8c,0x63,0x18,0xa8,0x80,0x8c,0x63,0x1a,0xee,0x20,0x8c,0x54,0x45,
		0x46,0x20,0x8c,0x54,0x42,0x10,0x80,0xf0,0x44,0x44,0x41,0xe0,0xea,0xac,
		0x00,0x08,0x44,0x22,0x10,0xd5,0x5c,0x00,0x54,0xf8,0x90,0x60,0x9d,0x27,
		0x80,0x88,0x8e,0x99,0x60,0x69,0x89,0x60,0x11,0x17,0x99,0x60,0x69,0xf8,
		0x60,0x34,0x4f,0x44,0x40,0x6b,0xb5,0x16,0x88,0x8e,0x99,0x90,0x5e,0x00,
		0x01,0x01,0x19,0x60,0x00,0x9a,0xca,0x90,0xfe,0x00,0x00,0x15,0x5a,0xc6,
		0x20,0x00,0x69,0x99,0x90,0x00,0x00,0xc9,0x49,0x80,0x00,0x69,0x9e,0x80,
		0x00,0x69,0x97,0x10,0x00,0x8b,0xc8,0x80,0x00,0x68,0x61,0x60,0x01,0x74,
		0x88,0x00,0x00,0x99,0x99,0x60,0x02,0xdb,0x50,0x00,0x00,0x23,0x1a,0xd5,
		0x40,0x00,0x22,0xa2,0x2a,0x20,0x00,0x22,0xa2,0x10,0x80,0x03,0x95,0x38,
		0x00,0x29,0x44,0x88,0x00,0xfe,0x00,0x89,0x14,0xa0,0x00,0x45,0x44,0x00
	]);

	console.log(`0x${Ferranti7Bitmaps[255].toString(16).padStart(2, "0")}`);
	console.log(`0x${Ferranti7Bitmaps[256].toString(16).padStart(2, "0")}`);
	console.log(`0x${Ferranti7Bitmaps[257].toString(16).padStart(2, "0")}`);

	// Each glyph entry: [bitmapOffset,width,height,xAdvance,xOffset,yOffset]
	const Ferranti7Glyphs = [
		[0,1,1,2,0,0],[1,1,7,2,0,-6],[3,3,2,4,0,-6],[4,5,7,6,0,-6],
		[9,5,7,6,0,-6],[14,5,7,6,0,-6],[0,0,0,0,0,0],[19,1,7,2,0,-6],
		[21,2,7,3,0,-6],[24,2,7,3,0,-6],[27,5,7,7,0,-6],[32,5,7,7,0,-6],
		[37,2,4,3,0,-1],[38,3,1,5,1,-3],[39,2,2,3,0,-1],[40,4,7,5,0,-6],
		[44,4,7,5,0,-6],[48,3,7,4,0,-6],[52,4,7,5,0,-6],[56,4,7,5,0,-6],
		[60,4,7,5,0,-6],[64,4,7,5,0,-6],[68,4,7,5,0,-6],[72,4,7,5,0,-6],
		[76,4,7,5,0,-6],[80,4,7,5,0,-6],[84,2,7,3,0,-6],[87,2,7,3,0,-6],
		[90,3,7,4,0,-6],[94,3,7,4,0,-6],[98,3,7,4,0,-6],[102,4,7,5,0,-6],
		[106,5,7,6,0,-6],[111,4,7,5,0,-6],[115,4,7,5,0,-6],[119,4,7,5,0,-6],
		[123,4,7,5,0,-6],[127,4,7,5,0,-6],[131,4,7,5,0,-6],[135,4,7,5,0,-6],
		[139,4,7,5,0,-6],[143,3,7,4,0,-6],[147,4,7,5,0,-6],[151,4,7,5,0,-6],
		[155,4,7,5,0,-6],[159,5,7,6,0,-6],[164,4,7,5,0,-6],[168,4,7,5,0,-6],
		[172,4,7,5,0,-6],[176,4,7,5,0,-6],[180,4,7,5,0,-6],[184,4,7,5,0,-6],
		[188,5,7,6,0,-6],[193,4,7,5,0,-6],[197,5,7,6,0,-6],[202,5,7,6,0,-6],
		[207,5,7,6,0,-6],[212,5,7,6,0,-6],[217,5,7,6,0,-6],[222,2,7,3,0,-6],
		[225,4,7,5,0,-6],[229,2,7,3,0,-6],[232,3,2,5,0,-6],[233,5,1,6,0,0],
		[234,2,2,3,0,-6],[235,5,5,6,0,-4],[239,4,7,5,0,-6],[243,4,5,5,0,-4],
		[246,4,7,5,0,-6],[250,4,5,5,0,-4],[253,4,7,5,0,-6],[257,4,6,5,0,-3],
		[260,4,7,5,0,-6],[264,1,7,2,0,-6],[266,4,7,5,0,-6],[270,4,7,5,0,-6],
		[274,1,7,2,0,-6],[276,5,7,6,0,-6],[281,4,7,5,0,-6],[285,5,7,5,0,-6],
		[290,4,7,5,0,-6],[294,4,7,5,0,-6],[298,4,7,5,0,-6],[302,4,7,5,0,-6],
		[306,3,7,4,0,-6],[310,4,7,5,0,-6],[314,3,7,4,0,-6],[318,5,7,6,0,-6],
		[323,5,7,6,0,-6],[328,5,7,6,0,-6],[333,3,7,4,0,-6],[337,3,7,4,0,-6],
		[341,1,7,3,1,-6],[343,3,7,4,0,-6],[347,5,3,6,0,-6]
	];

	/* ---------- Text rendering primitives ---------- */
	function clearPanel() {
		ctx.fillStyle = COLOR_BG;              // pure background
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		// draw every dot in its “off” state so they’re visible
		for (let y = 0; y < ROWS; y++) {
			for (let x = 0; x < COLS; x++) {
				setDot(x, y, false);               // false → COLOR_OFF circles
			}
		}
	}

	function setDot(x, y, on) {
		if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return;
		ctx.fillStyle = on ? COLOR_ON : COLOR_OFF;
		ctx.beginPath();
		const cx = x * SCALE + SCALE / 2;
		const cy = y * SCALE + SCALE / 2;
		ctx.arc(cx, cy, SCALE / 2 - 1, 0, Math.PI * 2);
		ctx.fill();
	}

	function drawGlyph(ch, originX, originY) {
		const code = ch.charCodeAt(0);
		if (code < 0x20 || code > 0x7e) return 0; // unsupported
		const g = Ferranti7Glyphs[code - 0x20];
		const [bitmapOffset, w, h, xAdvance, xOffset, yOffset] = g;
		for (let row = 0; row < h; row++) {
			for (let col = 0; col < w; col++) {
				const bitIndex = row * w + col;
				const byte = Ferranti7Bitmaps[bitmapOffset + (bitIndex >> 3)];
				const bit = 7 - (bitIndex & 7);
				const on = (byte >> bit) & 1;
				if (on) setDot(originX + xOffset + col, originY + yOffset + row, true);
			}
		}
		return xAdvance;
	}

	/* ---------- Word‑wrap helpers ---------- */
	function glyphWidth(ch) {
		const code = ch.charCodeAt(0);
		if (code < 0x20 || code > 0x7e) return 0;
		return Ferranti7Glyphs[code - 0x20][3]; // xAdvance
	}


	function wrapParagraph(txt) {
		const words = txt.split(/\s+/).filter(Boolean);
		const lines = [];
		let line = "";

		for (const word of words) {
			const candidate = line ? line + " " + word : word;
			if (textWidth(candidate) > COLS && line) {
				lines.push(line);
				line = word;
			} else {
				line = candidate;
			}
		}
		lines.push(line);
		return lines;
	}

	/* ─── Kerning support (same pairs as the Arduino sketch) ───────── */
	const KERNING = {
		"ay": -1,
		"yo": -1,
		"ss": -1,
		"st": -1,
		"at": -1,
		"r.": -1,
		"Te": -1,
		"To": -1,
		"Tu": -1,
		"as": -1,
		"sy": -1,
		"ra": -1,
		"__": -1,
		"by": -1,
		"rg": -1,
		"Pa": -1,
		"Tr": -1,
		"Ta": -1,
		"Ty": -1,

	};

	function kAdj(left, right) {
		return KERNING[left + right] ?? 0;   // unknown pair → 0
	}

	/* ─── Width of a string *with kerning* ─────────────────────────── */
	function textWidth(str) {
		let w = 0;
		for (let i = 0; i < str.length; i++) {
			const c = str[i];
			const n = str[i + 1] ?? "";
			w += glyphWidth(c) + kAdj(c, n);
		}
		return w;
	}

	/* ─── Draw one wrapped line with kerning ───────────────────────── */
	function drawLine(txt, ln) {
		const baseline = 7;      // first‑line y‑baseline
		const lineH = 9;         // glyph height + gap
		let x = 0;

		for (let i = 0; i < txt.length; i++) {
			const c = txt[i];
			const n = txt[i + 1] ?? "";
			x += drawGlyph(c, x, baseline + ln * lineH);
			x += kAdj(c, n);       // apply kerning shift
		}
	}

	/* ---------- Render (with wrapping) ---------- */
	function render(text) {
		clearPanel();

		const paragraphs = text.split("\n");
		let currentLine = 0;

		for (const p of paragraphs) {
			const lines = wrapParagraph(p);
			for (const l of lines) {
				if (currentLine * 9 + 7 > ROWS) return; // out of vertical space
				drawLine(l, currentLine);
				currentLine++;
			}
		}
	}

	/* ---------- Input handling ---------- */
	const input = document.getElementById("message");
	input.addEventListener("input", () => render(input.value));

	// Initial blank panel
	clearPanel();
</script>

</body>
</html>
